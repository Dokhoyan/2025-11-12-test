### Принципы чистой архитектуры

1. **Domain Layer** (`internal/domain`) - содержит бизнес-сущности без зависимостей от внешних слоев
2. **Repository Layer** (`internal/repository`) - абстракция доступа к данным через интерфейсы
3. **Service Layer** (`internal/service`) - бизнес-логика приложения и внешние сервисы:
   - Бизнес-логика: `LinkService`, `ReportService`
   - Внешние сервисы: `HTTPLinkChecker`, `FPDFGenerator`
4. **Handler Layer** (`internal/handler`) - HTTP обработчики, преобразование запросов/ответов
5. **Server Layer** (`internal/server`) - настройка и запуск HTTP сервера

## Реализация требований

### 1. Прием ссылок (одной или нескольких)

**Реализация:** 
- Endpoint: `POST /links`
- Request body: `{"urls": ["http://example.com", "http://example.org"]}`
- Response: `{"id": 1, "links": [{"url": "...", "status": "available"}, ...]}`

**За счет чего выполняется:**
- HTTP handler (`internal/handler/link.go`) принимает JSON запрос через middleware
- Middleware (`internal/handler/middleware.go`) логирует запросы и проверяет HTTP методы
- Валидация запроса проверяет корректность входных данных
- Сервис работы со ссылками (`internal/service/link_service.go`) обрабатывает бизнес-логику
- Сервис проверки ссылок (`internal/service/checker.go`) параллельно проверяет все ссылки через HTTP запросы
- Репозиторий (`internal/repository/file_repository.go`) сохраняет результат с присвоенным номером
- Унифицированная обработка ответов (`internal/handler/response.go`) формирует JSON ответы

### 2. Возврат статусов и номера набора ссылок

**Реализация:**
- При добавлении ссылок сервер автоматически присваивает уникальный номер (ID)
- Статус каждой ссылки проверяется и возвращается в ответе
- Статусы: `"available"` (доступен) или `"unavailable"` (недоступен)

**За счет чего выполняется:**
- Репозиторий использует счетчик `nextID` для генерации уникальных номеров
- HTTP checker проверяет доступность через GET запрос с таймаутом 10 секунд
- Статус определяется по HTTP статус-коду ответа (2xx-3xx = available, остальное = unavailable)
- Проверка ссылок выполняется параллельно в горутинах для ускорения

### 3. Генерация PDF отчета по списку номеров

**Реализация:**
- Endpoint: `POST /report`
- Request body: `{"links_num": [1, 2, 3]}`
- Response: PDF файл с отчетом о статусе всех ссылок из указанных наборов

**За счет чего выполняется:**
- Handler принимает список номеров наборов ссылок
- Сервис генерации отчетов (`internal/service/report_service.go`) получает данные из репозитория
- PDF генератор (`internal/service/pdf_generator.go`) использует библиотеку `codeberg.org/go-pdf/fpdf` для создания PDF
- Отчет содержит информацию о каждом наборе ссылок с их статусами (цветовая индикация: зеленый для available, красный для unavailable)

### 4. Graceful Shutdown без потери задач

**Реализация:**
- Сервер обрабатывает сигналы `SIGINT` и `SIGTERM`
- При получении сигнала:
  1. Прекращается прием новых соединений
  2. Дается 30 секунд на завершение текущих HTTP запросов
  3. Сохраняются все данные в файл
  4. Сервер корректно завершает работу

**За счет чего выполняется:**
- Использование `http.Server.Shutdown()` из стандартной библиотеки Go, который:
  - Останавливает прием новых соединений
  - Ждет завершения активных запросов (до 30 секунд)
  - Корректно закрывает все соединения
- Репозиторий сохраняет данные при каждом изменении (синхронная запись в файл)
- При shutdown вызывается `repo.Close()` для финального сохранения данных
- Использование `context.Context` в проверке ссылок позволяет корректно отменять долгие операции
- Файловое хранилище использует атомарную запись (через временный файл + rename) для предотвращения потери данных при сбоях

### 5. Обработка новых задач во время остановки

**Реализация:**
- Во время graceful shutdown сервер продолжает обрабатывать уже принятые соединения
- Новые соединения не принимаются после начала shutdown
- Все задачи, которые начали обрабатываться до shutdown, завершаются

**За счет чего выполняется:**
- `http.Server.Shutdown()` не принимает новые соединения, но обрабатывает уже установленные
- Таймаут 30 секунд дает достаточно времени для завершения большинства операций
- Если операция не завершилась за 30 секунд, она прерывается, но данные уже сохранены в репозитории

## Используемые паттерны

1. **Repository Pattern** - абстракция доступа к данным через интерфейсы
2. **Dependency Injection** - зависимости передаются через конструкторы
3. **Interface Segregation** - маленькие, специфичные интерфейсы
4. **Graceful Shutdown** - корректное завершение работы с сохранением состояния
5. **Context Pattern** - использование context для отмены операций и таймаутов
6. **Middleware Pattern** - промежуточное ПО для логирования и валидации методов
7. **Error Handling Pattern** - унифицированная обработка ошибок через функции-обертки
8. **Validation Pattern** - валидация входных данных на уровне handlers


## Запуск

```bash
go run cmd/server/main.go [data_file]
```

По умолчанию данные сохраняются в файл `data.json`. Можно указать другой файл как аргумент.

Порт по умолчанию: `8080`. Можно изменить через переменную окружения `PORT`.

## API Endpoints

### POST /links
Добавление ссылок для проверки.

**Request:**
```json
{
  "urls": ["http://example.com", "http://example.org"]
}
```

**Response:**
```json
{
  "id": 1,
  "links": [
    {"url": "http://example.com", "status": "available"},
    {"url": "http://example.org", "status": "unavailable"}
  ]
}
```

### POST /report
Генерация PDF отчета по списку номеров наборов ссылок.

**Request:**
```json
{
  "links_num": [1, 2, 3]
}
```

**Response:** PDF файл (Content-Type: application/pdf)

### GET /links/get?id=1
Получение информации о наборе ссылок по номеру.

**Response:**
```json
{
  "id": 1,
  "links": [
    {"url": "http://example.com", "status": "available"}
  ]
}
```

## Хранение данных

Данные хранятся в JSON файле (по умолчанию `data.json`). Структура файла:

```json
{
  "link_sets": {
    "1": {
      "id": 1,
      "links": [...],
      "created_at": "..."
    }
  },
  "next_id": 2
}
```

Файл сохраняется синхронно при каждом изменении данных. Используется атомарная запись (через временный файл) для предотвращения потери данных при сбоях.

## Дополнительные замечания

1. **Таймауты:** Проверка ссылок выполняется с таймаутом 10 секунд на запрос
2. **Параллелизм:** Проверка нескольких ссылок выполняется параллельно в горутинах
3. **Без внешних зависимостей:** Не используются Docker, внешние БД, nginx - только стандартная библиотека Go и библиотека для PDF
4. **Восстановление после перезапуска:** Все данные сохраняются в файл и автоматически загружаются при запуске сервера

